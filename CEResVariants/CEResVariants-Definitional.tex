\section{Using Structural Clause Form Transformation}
\label{sec:StructuralClauseForm}


In order to avoid the exponential blow-up in the size of the clause set altogether, this section investigates the use of \emph{structural clause form transformation} \cite{BaazEglyLeitsch2001NormalFormTransformations}, which avoids the distribution of disjunction over conjunction by introducing new defined predicate symbols for each subformula of the formula to be normalized. The number of new predicate symbols is, therefore, linear w.r.t. to the size of the formula. Moreover, each literal is duplicated only a constant number of times. 


\begin{definition}[$\normalizePlusTimesD$]
\label{definition:NormalizationPlusTimesDefinitional}
For every conjunctive or disjunctive formula $S$ with free variables $x_1,\ldots, x_m$, a new predicate symbol $N_{S}(x_1,\ldots, x_m)$ can be created together with its corresponding defining formula:
%
\begin{small}
$$
D_{S} \ \ \defEq \ \
N_{S_1 \structplus \ldots \structplus S_n}(x_1,\ldots, x_m) 
%\biimp N_{n(S'_1) \structplus \ldots \structplus n(S'_n)}(x_1,\ldots, x_m) 
\biimp n(S_1) \structplus \ldots \structplus n(S_n)
$$
$$
D_{S} \ \ \defEq \ \  
N_{S_1 \structtimes \ldots \structtimes S_n}(x_1,\ldots, x_m) 
%\biimp N_{n(S'_1) \structtimes \ldots \structtimes n(S'_n)}(x_1,\ldots, x_m) 
\biimp n(S_1) \structtimes \ldots \structtimes n(S_n)
$$
\end{small}
where:
\begin{small}
$$
n(S_k) = \left\{ \begin{array}{ll}
S_k & \textrm{, if } S_k \textrm{ is a literal} \\
N_{S_k}(y_1,\ldots, y_j) & \textrm{, if } S_k \textrm{ is a non-literal with free variables } y_1,\ldots, y_j
\end{array}\right.
$$
\end{small}

\noindent
Then:
\begin{small}
$$
S \normalizePlusTimesD n(S) \structplus \structplusBig_{\scriptscriptstyle S' \in sub(S) } D_{S'}
$$
\end{small}
where $sub(S)$ is the set of non-literal subformulas of $S$.
\end{definition}

\begin{remark}
The connective $\biimp$ is considered to be just an abbreviation:
\begin{small}
$$
A \biimp B_1 \structtimes \ldots \structtimes B_n \defEq 
(\overline{A} \structtimes B_1 \structtimes \ldots \structtimes B_n) \structplus 
(\overline{B_1} \structtimes A) \structplus \ldots \structplus 
(\overline{B_n} \structtimes A)
$$
$$
A \biimp B_1 \structplus \ldots \structplus B_n \defEq 
(\overline{B_1} \structtimes \ldots \structtimes \overline{B_n} \structtimes A ) \structplus 
(\overline{A} \structtimes B_1) \structplus \ldots \structplus 
(\overline{A} \structtimes B_n)
$$
\end{small}
where $\overline{C}$ is $\structdual D$, if $C = D$, and $D$, if $C = \structdual D$.
\end{remark}


\begin{definition}[Definitional Clause Set]
\label{definition:ClauseSetDefinitional}
The \emph{definitional clause set} $\clausesetDefinitional{\varphi}$ of a 
proof $\varphi$ is the $\normalizePlusTimesD$-normal-form of $\struct{\varphi}$ 
written in sequent notation. Clauses in $\clausesetDefinitional{\varphi}$ are either the \emph{proper clause} $\seq n(\struct{\varphi})$ or \emph{definitional clauses} originating from the defining formulas $D_{S'}$ for each subformula $S'$ of $\struct{\varphi}$.
\end{definition}

\begin{example}
\label{example:PlusTimesDefinitionalNormalization}
Let $\varphi$ be the proof shown in Example \ref{example:CutPertinentStruct}, whose characteristic formulas is:
% \begin{prooftree}
% \AXC{$\hA{A} \seq \hA{A} $}
% 		\AXC{$\hB{B} \seq \hB{B}$} \RightLabel{$\wedge_r^1$}
% 	\BIC{$\hA{A}, \hB{B} \seq \hA{A} \wedge \hB{B}$} \RightLabel{$\wedge_l$}
% 	\UIC{$\hA{A} \wedge \hB{B} \seq \hA{A} \wedge \hB{B}$}
% 				\AXC{$\hC{B} \seq \hC{B} $}
% 						\AXC{$\hD{A} \seq \hD{A}$} \RightLabel{$\wedge_r^2$}
% 					\BIC{$\hD{A}, \hC{B} \seq \hC{B} \wedge \hD{A}$} \RightLabel{$\wedge_l$}
% 					\UIC{$\hD{A} \wedge \hC{B} \seq \hC{B} \wedge \hD{A}$} \RightLabel{$cut^3$}
% 			\BIC{$\hA{A} \wedge \hB{B} \seq \hC{B} \wedge \hD{A}$}
% 							\AXC{$\hE{C} \seq \hE{C}$} 
% 									\AXC{$\hF{C} \seq \hF{C}$} \RightLabel{$cut^4$}
% 								\BIC{$\hE{C} \seq \hF{C}$} \RightLabel{$\vee_l^5$}
% 					\BIC{$(\hA{A} \wedge \hB{B}) \vee \hE{C} \seq \hC{B} \wedge \hD{A}, \hF{C} $} 
% \end{prooftree}
$$
\struct{\varphi} 
\equiv 
((\hA{A} \structplus \hB{B}) \structplus (\hC{\structdual{B}} \structtimes \hD{\structdual{A}}))
\structtimes
(\hE{C} \structplus \hF{\structdual{C}})
$$

\noindent
New predicate symbols can be created and defined by the following formulas: 
\begin{itemize}
\item $D \biimp \hE{C} \structplus \hF{\structdual{C}}$

\item $E \biimp \hC{\structdual{B}} \structtimes \hD{\structdual{A}}$

\item $F \biimp \hA{A} \structplus \hB{B}$

\item $G \biimp F \structplus E$

\item $H \biimp G \structtimes D$
\end{itemize}

\noindent
The $\normalizePlusTimesD$-normal-form of $\struct{\varphi}$ is:
$$
\begin{array}{rcl}
S^*	
& \defEq & H \structplus \\
&			& 
(\structdual D \structtimes \hE{C})
\structplus
(\structdual D \structtimes \structdual \hF{C})
\structplus
( \structdual \hE{C} \structtimes D \structtimes \hF{C}) \structplus \\
&			&
(\structdual E \structtimes \structdual \hC{B} \structtimes \structdual \hD{A} )
\structplus
(E \structtimes \hC{B})
\structplus
(E \structtimes \hD{A}) \structplus \\
&			&
(\structdual F \structtimes \hA{A})
\structplus
(\structdual F \structtimes \hB{B})
\structplus
(\structdual \hA{A} \structtimes \structdual \hB{B} \structtimes F) \structplus \\
&			&
(\structdual G \structtimes F)
\structplus
(\structdual G \structtimes E)
\structplus
(\structdual E \structtimes \structdual F \structtimes G) \structplus \\
&			&
(\structdual H \structtimes G \structtimes D)
\structplus
(\structdual G \structtimes H)
\structplus
(\structdual D \structtimes H) \\
\end{array}
$$

\noindent
The definitional clause set $\clausesetDefinitional{\varphi}$ consists of the following clauses. The proper clause is $\seq H$. All other clauses are definitional clauses.

\begin{multicols}{3}{
{
$\seq H$

$D \seq \hE{C}$

$E, \hC{B}, \hD{A} \seq $

$F \seq \hA{A}$

$G \seq F$

$H \seq G, D$
}

{
$\phantom{\seq H}$

$D, \hF{C} \seq $

$\seq E, \hC{B}$

$F \seq \hB{B}$

$G \seq E$

$G \seq H$
}

{
$\phantom{\seq H}$

$ \hE{C} \seq D, \hF{C}$

$\seq E, \hD{A}$

$\hA{A}, \hB{B} \seq F$

$E, F \seq G$

$D \seq H$
}
}\end{multicols}
\hfill\QED
\end{example}

The construction of projections requires special care when definitional clause sets are used. The reason is that the clauses now contain many new predicate symbols which do not occur in the input proof. Fortunately, for all definitional clauses of a definitional clause set, projections can be constructed easily and independently of the input proof, by using definition inference rules in the sequent calculus.

\begin{definition}[Definitional Projection]
\label{definition:DProjectionDefinitional}
The \emph{definitional projection} $\projectionDefinitional{\varphi}{c}$ of 
a proof $\varphi$ w.r.t. a definitional clause $c$ from 
$\clausesetDefinitional{\varphi}$ can be constructed according 
to one of the following templates:

\begin{tiny}
\begin{multicols}{2}{
\begin{prooftree}
\AXC{$n(S_1) \seq n(S_1)$}
	\AXC{$\ldots$}
		\AXC{$n(S_n) \seq n(S_n)$} \doubleLine \RightLabel{$\vee^*_l$}
	\TIC{$n(S_1) \vee \ldots \vee n(S_n) \seq n(S_1), \ldots , n(S_n)$} \RightLabel{$d_l$}
	\UIC{$N_{S_1 \structtimes \ldots \structtimes S_n}(x_1,\ldots, x_m) \seq  n(S_1), \ldots , n(S_n)$} 
\end{prooftree}


\begin{prooftree}
\AXC{$n(S_k) \seq n(S_k)$} \doubleLine \RightLabel{$w^*_r$}
\UIC{$n(S_k) \seq n(S_1), \ldots, n(S_n)$} \doubleLine \RightLabel{$\vee^*_r$}
\UIC{$n(S_k) \seq n(S_1) \vee \ldots \vee n(S_n)$} \RightLabel{$d_r$}
\UIC{$n(S_k) \seq N_{S_1 \structtimes \ldots \structtimes S_n}(x_1,\ldots, x_m)$}
\end{prooftree}
}\end{multicols}
\end{tiny}


\begin{tiny}
\begin{multicols}{2}{
\begin{prooftree}
\AXC{$n(S_1) \seq n(S_1)$}
	\AXC{$\ldots$}
		\AXC{$n(S_n) \seq n(S_n)$} \doubleLine \RightLabel{$\wedge^*_r$}
	\TIC{$n(S_1), \ldots , n(S_n) \seq n(S_1) \wedge \ldots \wedge n(S_n)$} \RightLabel{$d_r$}
	\UIC{$n(S_1), \ldots , n(S_n) \seq  N_{S_1 \structplus \ldots \structplus S_n}(x_1,\ldots, x_m)$} 
\end{prooftree}


\begin{prooftree}
\AXC{$n(S_k) \seq n(S_k)$} \doubleLine \RightLabel{$w^*_l$}
\UIC{$n(S_1), \ldots, n(S_n)\seq n(S_k)$} \doubleLine \RightLabel{$\wedge^*_l$}
\UIC{$n(S_1) \wedge \ldots \wedge n(S_n) \seq n(S_k)$} \RightLabel{$d_l$}
\UIC{$N_{S_1 \structplus \ldots \structplus S_n}(x_1,\ldots, x_m) \seq n(S_k)$} 
\end{prooftree}
}\end{multicols}
\end{tiny}

\noindent
If $S_k$ is a negative literal, it is necessary to add negation inferences to the definitional projections above.
\end{definition}


\begin{example}
\label{example:DProjectionDefinitional}
Definitional projections w.r.t. the clauses shown in Example \ref{example:PlusTimesDefinitionalNormalization} are:

\begin{multicols}{3}{
$\projectionDefinitional{\varphi}{D \seq \hE{C}}$:
\begin{prooftree}
\AXC{$\hE{C} \seq \hE{C}$} \RightLabel{$w_l$}
\UIC{$\hE{C}, \neg \hF{C} \seq \hE{C}$} \RightLabel{$\wedge_l$}
\UIC{$\hE{C} \wedge \neg \hF{C} \seq \hE{C}$} \RightLabel{$d_l$}
\UIC{$D \seq \hE{C}$} 
\end{prooftree}
\vfill\columnbreak


$\projectionDefinitional{\varphi}{D, \hF{C} \seq }$:
\begin{prooftree}
\AXC{$\hF{C} \seq \hF{C}$} \RightLabel{$w_l$}
\UIC{$\hE{C}, \hF{C} \seq \hF{C}$} \RightLabel{$\neg_l$}
\UIC{$\hE{C}, \neg \hF{C}, \hF{C} \seq $} \RightLabel{$\wedge_l$}
\UIC{$\hE{C} \wedge \neg \hF{C}, \hF{C} \seq $} \RightLabel{$d_l$}
\UIC{$D, \hF{C} \seq $} 
\end{prooftree}

$\projectionDefinitional{\varphi}{\hE{C} \seq D, \hF{C}}$:
\begin{prooftree}
\AXC{$\hE{C} \seq \hE{C}$}
		\AXC{$\hF{C} \seq \hF{C}$} \RightLabel{$\neg_r$}
		\UIC{$ \seq  \hF{C}, \neg \hF{C}$} \RightLabel{$\wedge_r$}
	\BIC{$\hE{C} \seq \hF{C}, \hE{C} \wedge \neg \hF{C}$} \RightLabel{$d_r$}
	\UIC{$\hE{C} \seq \hF{C}, D$} 
\end{prooftree}
}
\end{multicols}


\begin{multicols}{3}{
$\projectionDefinitional{\varphi}{\seq E, \hD{A}}$:
\begin{prooftree}
\AXC{$\hD{A} \seq \hD{A}$} \RightLabel{$\neg_r$}
\UIC{$\seq \neg \hD{A}, \hD{A}$} \RightLabel{$w_r$}
\UIC{$\seq \neg \hC{B}, \neg \hD{A}, \hD{A}$} \RightLabel{$\vee_r$}
\UIC{$\seq \neg \hC{B} \vee \neg \hD{A}, \hD{A}$} \RightLabel{$d_r$}
\UIC{$\seq E, \hD{A}$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{\seq E, \hC{B}}$:
\begin{prooftree}
\AXC{$\hC{B} \seq \hC{B}$} \RightLabel{$\neg_r$}
\UIC{$\seq \neg \hC{B}, \hC{B}$} \RightLabel{$w_r$}
\UIC{$\seq \neg \hC{B}, \neg \hD{A}, \hC{B}$} \RightLabel{$\vee_r$}
\UIC{$\seq \neg \hC{B} \vee \neg \hD{A}, \hC{B}$} \RightLabel{$d_r$}
\UIC{$\seq E, \hC{B}$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{E, \hD{A}, \hC{B} \seq }$:
\begin{small}
\begin{prooftree}
\AXC{$\hC{B} \seq \hC{B}$} \RightLabel{$\neg_l$}
\UIC{$\neg \hC{B}, \hC{B} \seq $}
		\AXC{$\hD{A} \seq \hD{A}$} \RightLabel{$\neg_l$}
		\UIC{$\neg \hD{A}, \hD{A} \seq $} \RightLabel{$\vee_l$}
	\BIC{$\neg \hC{B} \vee \neg \hD{A}, \hC{B}, \hD{A} \seq $} \RightLabel{$d_l$}
	\UIC{$E, \hC{B}, \hD{A} \seq $} 
\end{prooftree}
\end{small}
}
\end{multicols}




\begin{multicols}{3}{
$\projectionDefinitional{\varphi}{F \seq \hA{A}}$:
\begin{prooftree}
\AXC{$\hA{A} \seq \hA{A}$} \RightLabel{$w_l$}
\UIC{$\hA{A}, \hB{B} \seq \hA{A}$} \RightLabel{$\wedge_l$}
\UIC{$\hA{A} \wedge \hB{B} \seq \hA{A}$} \RightLabel{$d_l$}
\UIC{$F \seq \hA{A}$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{F \seq \hB{B}}$:
\begin{prooftree}
\AXC{$\hB{B} \seq \hB{B}$} \RightLabel{$w_l$}
\UIC{$\hA{A}, \hB{B} \seq \hB{B}$} \RightLabel{$\wedge_l$}
\UIC{$\hA{A} \wedge \hB{B} \seq \hB{B}$} \RightLabel{$d_l$}
\UIC{$F \seq \hB{B}$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{\hA{A}, \hB{B} \seq F}$:
\begin{prooftree}
\AXC{$\hA{A} \seq \hA{A}$}
		\AXC{$\hB{B} \seq \hB{B}$} \RightLabel{$\wedge_r$}
	\BIC{$\hA{A}, \hB{B} \seq \hA{A} \wedge \hB{B}$} \RightLabel{$d_r$}
	\UIC{$\hA{A}, \hB{B} \seq F$} 
\end{prooftree}
}
\end{multicols}





\begin{multicols}{3}{
$\projectionDefinitional{\varphi}{G \seq F}$:
\begin{prooftree}
\AXC{$F \seq F$} \RightLabel{$w_l$}
\UIC{$F, E \seq F$} \RightLabel{$\wedge_l$}
\UIC{$F \wedge E \seq F$} \RightLabel{$d_l$}
\UIC{$G \seq F$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{G \seq E}$:
\begin{prooftree}
\AXC{$E \seq E$} \RightLabel{$w_l$}
\UIC{$F, E \seq E$} \RightLabel{$\wedge_l$}
\UIC{$F \wedge E \seq E$} \RightLabel{$d_l$}
\UIC{$G \seq E$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{F, E \seq G}$:
\begin{prooftree}
\AXC{$F \seq F$}
		\AXC{$E \seq E$} \RightLabel{$\wedge_r$}
	\BIC{$F, E \seq F \wedge E$} \RightLabel{$d_r$}
	\UIC{$F, E \seq G$} 
\end{prooftree}
}
\end{multicols}


\begin{multicols}{3}{
$\projectionDefinitional{\varphi}{D \seq H}$:
\begin{prooftree}
\AXC{$D \seq D$} \RightLabel{$w_r$}
\UIC{$D \seq G, D$} \RightLabel{$\vee_r$}
\UIC{$D \seq G\vee D$} \RightLabel{$d_r$}
\UIC{$D \seq H$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{G \seq H}$:
\begin{prooftree}
\AXC{$G \seq G$} \RightLabel{$w_r$}
\UIC{$G \seq G, D$} \RightLabel{$\vee_r$}
\UIC{$G \seq G\vee D$} \RightLabel{$d_r$}
\UIC{$G \seq H$} 
\end{prooftree}

$\projectionDefinitional{\varphi}{H \seq G, D}$:
\begin{prooftree}
\AXC{$G \seq G$}
		\AXC{$D \seq D$} \RightLabel{$\vee_l$}
	\BIC{$G \vee D \seq G, D$} \RightLabel{$d_l$}
	\UIC{$H \seq G, D$} 
\end{prooftree}
}
\end{multicols}
\hfill\QED
\end{example}

