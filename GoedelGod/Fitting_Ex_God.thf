%--------------------------------------------------------------------------
% File:  Fitting_Ex_God.thf
% Domain: Modal Logic 
% Problem: 
% Version: 
% English: Goedel's ontological argument on the existence of God; [1], p.36
% Refs: [1] Melvin Fitting, Higher-Order Modal Logic -- A Sketch, Automated Deduction, LNAI 1761, pp. 23-38, 2000
% Source: Formalization by C. Benzmueller 
% Names: 
% Status: should be a Theorem (in Henkin Semantics)
% Rating: 
% Syntax: 
% Comments: 
%--------------------------------------------------------------------------
%----Declaration of additional base type mu (for individuals)
%----type $i stands for possible worlds
thf(mu_type,type,(
    mu: $tType )).

%----Modal operators not, or, box
thf(mnot_type,type,(
    mnot: ( $i > $o ) > $i > $o )).

thf(mnot,definition,
    ( mnot
    = ( ^ [Phi: $i > $o,W: $i] :
          ~ ( Phi @ W ) ) )).

thf(mor_type,type,(
    mor: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mor,definition,
    ( mor
    = ( ^ [Phi: $i > $o,Psi: $i > $o,W: $i] :
          ( ( Phi @ W )
          | ( Psi @ W ) ) ) )).

thf(mbox_type,type,(
    mbox: ( $i > $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mbox,definition,
    ( mbox
    = ( ^ [R: $i > $i > $o,Phi: $i > $o,W: $i] :
        ! [V: $i] :
          ( ~ ( R @ W @ V )
          | ( Phi @ V ) ) ) )).

%----Modal quantifier (as constant Pi) for individuals and propositions 

thf(mforall_ind_type,type,(
    mforall_ind: ( mu > $i > $o ) > $i > $o )).

thf(mforall_ind,definition,
    ( mforall_ind
    = ( ^ [Phi: mu > $i > $o,W: $i] :
        ! [X: mu] :
          ( Phi @ X @ W ) ) )).

thf(mforall_prop_type,type,(
    mforall_prop: ( ( $i > $o ) > $i > $o ) > $i > $o )).

thf(mforall_prop,definition,
    ( mforall_prop
    = ( ^ [Phi: ( $i > $o ) > $i > $o,W: $i] :
        ! [P: $i > $o] :
          ( Phi @ P @ W ) ) )).

%----Modal quantifier (as constant Pi) for sets of individuals (higher-order!)
%----this is new!

thf(mforall_indset_type,type,(
    mforall_indset: ( ( mu > $i > $o ) > $i > $o ) > $i > $o )).

thf(mforall_indset,definition,
    ( mforall_indset
    = ( ^ [Phi: ( mu > $i > $o ) > $i > $o,W: $i] :
        ! [X: mu > $i > $o] :
          ( Phi @ X @ W ) ) )).

%----Further modal operators
thf(mtrue_type,type,(
    mtrue: $i > $o )).

thf(mtrue,definition,
    ( mtrue
    = ( ^ [W: $i] : $true ) )).

thf(mfalse_type,type,(
    mfalse: $i > $o )).

thf(mfalse,definition,
    ( mfalse
    = ( mnot @ mtrue ) )).

thf(mand_type,type,(
    mand: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mand,definition,
    ( mand
    = ( ^ [Phi: $i > $o,Psi: $i > $o] :
          ( mnot @ ( mor @ ( mnot @ Phi ) @ ( mnot @ Psi ) ) ) ) )).

thf(mimplies_type,type,(
    mimplies: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mimplies,definition,
    ( mimplies
    = ( ^ [Phi: $i > $o,Psi: $i > $o] :
          ( mor @ ( mnot @ Phi ) @ Psi ) ) )).

thf(mimplied_type,type,(
    mimplied: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mimplied,definition,
    ( mimplied
    = ( ^ [Phi: $i > $o,Psi: $i > $o] :
          ( mor @ ( mnot @ Psi ) @ Phi ) ) )).

thf(mequiv_type,type,(
    mequiv: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mequiv,definition,
    ( mequiv
    = ( ^ [Phi: $i > $o,Psi: $i > $o] :
          ( mand @ ( mimplies @ Phi @ Psi ) @ ( mimplies @ Psi @ Phi ) ) ) )).

thf(mxor_type,type,(
    mxor: ( $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mxor,definition,
    ( mxor
    = ( ^ [Phi: $i > $o,Psi: $i > $o] :
          ( mnot @ ( mequiv @ Phi @ Psi ) ) ) )).

thf(mdia_type,type,(
    mdia: ( $i > $i > $o ) > ( $i > $o ) > $i > $o )).

thf(mdia,definition,
    ( mdia
    = ( ^ [R: $i > $i > $o,Phi: $i > $o] :
          ( mnot @ ( mbox @ R @ ( mnot @ Phi ) ) ) ) )).

thf(mexists_ind_type,type,(
    mexists_ind: ( mu > $i > $o ) > $i > $o )).

thf(mexists_ind,definition,
    ( mexists_ind
    = ( ^ [Phi: mu > $i > $o] :
          ( mnot
          @ ( mforall_ind
            @ ^ [X: mu] :
                ( mnot @ ( Phi @ X ) ) ) ) ) )).

thf(mexists_prop_type,type,(
    mexists_prop: ( ( $i > $o ) > $i > $o ) > $i > $o )).

thf(mexists_prop,definition,
    ( mexists_prop
    = ( ^ [Phi: ( $i > $o ) > $i > $o] :
          ( mnot
          @ ( mforall_prop
            @ ^ [P: $i > $o] :
                ( mnot @ ( Phi @ P ) ) ) ) ) )).

%----Definition of validity
thf(mvalid_type,type,(
    mvalid: ( $i > $o ) > $o )).

thf(mvalid,definition,
    ( mvalid
    = ( ^ [Phi: $i > $o] :
        ! [W: $i] :
          ( Phi @ W ) ) )).

%----Definition of properties of accessibility relations
thf(mreflexive_type,type,(
    mreflexive: ( $i > $i > $o ) > $o )).

thf(mreflexive,definition,
    ( mreflexive
    = ( ^ [R: $i > $i > $o] :
        ! [S: $i] :
          ( R @ S @ S ) ) )).

thf(msymmetric_type,type,(
    msymmetric: ( $i > $i > $o ) > $o )).

thf(msymmetric,definition,
    ( msymmetric
    = ( ^ [R: $i > $i > $o] :
        ! [S: $i,T: $i] :
          ( ( R @ S @ T )
         => ( R @ T @ S ) ) ) )).

thf(mtransitive_type,type,(
    mtransitive: ( $i > $i > $o ) > $o )).

thf(mtransitive,definition,
    ( mtransitive
    = ( ^ [R: $i > $i > $o] :
        ! [S: $i,T: $i,U: $i] :
          ( ( ( R @ S @ T )
            & ( R @ T @ U ) )
         => ( R @ S @ U ) ) ) )).

%------------------------------------------------------------------------------
%----We work with an S5 logic
%----We reserve an accessibility relation constant rel_s5
thf(rel_s5_type,type,(
    rel_s5: $i > $i > $o )).

%----We define mbox_s5 and mdia_s5 based on rel_s5
thf(mbox_s5_type,type,(
    mbox_s5: ( $i > $o ) > $i > $o )).

thf(mbox_s5,definition,
    ( mbox_s5
    = ( ^ [Phi: $i > $o,W: $i] :
        ! [V: $i] :
          ( ~ ( rel_s5 @ W @ V )
          | ( Phi @ V ) ) ) )).

thf(mdia_s5_type,type,(
    mdia_s5: ( $i > $o ) > $i > $o )).

thf(mdia_s5,definition,
    ( mdia_s5
    = ( ^ [Phi: $i > $o] :
          ( mnot @ ( mbox_s5 @ ( mnot @ Phi ) ) ) ) )).

%----We have now two options for stating the S5 conditions: 
%----We can (i) directly formulate conditions for the accessibility relation
%----constant or we can (ii) state corresponding axioms. We here prefer (i)
thf(a1,axiom,
    ( mreflexive @ rel_s5 )).

thf(a2,axiom,
    ( mtransitive @ rel_s5 )).

thf(a3,axiom,
    ( msymmetric @ rel_s5 )).

%------------------------------------------------------------------------------

%----Signature 
thf(p_tp,type,(
    p: ( mu > $i > $o ) > $i > $o )).

thf(g_tp,type,(
    g: mu > $i > $o )).

thf(e_tp,type,(
    e: ( mu > $i > $o ) > mu > $i > $o )).

%----Definitions 
%----Axioms 
thf(positiveness,axiom,
    ( mvalid
    @ ( mforall_indset
      @ ^ [X: mu > $i > $o] :
          ( mimplies @ ( mnot @ ( p @ X ) )
          @ ( p
            @ ^ [Z: mu] :
                ( mnot @ ( X @ Z ) ) ) ) ) )).

thf(g_def,definition,
    ( g
    = ( ^ [Z: mu] :
          ( mforall_indset
          @ ^ [X: mu > $i > $o] :
              ( mimplies @ ( p @ X ) @ ( X @ Z ) ) ) ) )).

thf(e_def,definition,
    ( e
    = ( ^ [X: mu > $i > $o,Z: mu] :
          ( mforall_indset
          @ ^ [Y: mu > $i > $o] :
              ( mimplies @ ( Y @ Z )
              @ ( mbox_s5
                @ ( mforall_ind
                  @ ^ [W: mu] :
                      ( mimplies @ ( X @ W ) @ ( Y @ W ) ) ) ) ) ) ) )).

%----Conjecture 
% Now we show one step of Goedelâ€™s argument: (Forall x)[G(x) => E(G,x)]. 
% That is, being God is the essence of anything that is, in fact, God. 
thf(thm,conjecture,
    ( mvalid
    @ ( mforall_ind
      @ ^ [Z: mu] :
          ( mimplies @ ( g @ Z ) @ ( e @ g @ Z ) ) ) )).






